{"meta":{"title":"YWM'S BLOG","subtitle":"","description":"","author":"YWM","url":"https://blog.xsaistudio.cn","root":"/"},"pages":[],"posts":[{"title":"stage","slug":"stage","date":"2023-05-14T12:20:38.000Z","updated":"2023-05-14T12:24:06.710Z","comments":true,"path":"2023/05/14/stage/","link":"","permalink":"https://blog.xsaistudio.cn/2023/05/14/stage/","excerpt":"classification","text":"classification Random Forest1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# 使用决策树，随机森林模型from sklearn.ensemble import RandomForestClassifier# 训练数据train_data = pd.read_csv(&quot;Input/titanic/train.csv&quot;)# print(train_data.head().isnull().sum()) # 检测是否有缺失数据# 测试数据test_data = pd.read_csv(&quot;Input/titanic/test.csv&quot;)# test_data.head()# 选出男女的存活人数women = train_data.loc[train_data.Sex == &#x27;female&#x27;][&quot;Survived&quot;]men = train_data.loc[train_data.Sex == &#x27;male&#x27;][&quot;Survived&quot;]# print(men)rate_men = sum(men)/len(men) # 计算男人存活的概率# print(women)rate_women = sum(women)/len(women) # 计算女人存活的概率# print(&quot;% of women who survived:&quot;, rate_women)# print(&quot;% of men who survived:&quot;, rate_men)y = train_data[&quot;Survived&quot;]# print(y)# 这里有四个featurefeatures = [&quot;Pclass&quot;, &quot;Sex&quot;, &quot;SibSp&quot;, &quot;Parch&quot;]# 使用on hot encode方法，将数据中的文字转化为数字# print(train_data[features].head(10))X = pd.get_dummies(train_data[features])print(X.head(10))# 获得测试数据中四个feature的数据X_test = pd.get_dummies(test_data[features])# 开始训练模型# 初始化模型的超参数model = RandomForestClassifier(n_estimators=100, max_depth=5, random_state=1)&quot;&quot;&quot;n_estimators：这个参数指定了随机森林中决策树的数量（默认值为100）。更多的决策树可以提高模型的稳定性和准确性，但同时也会增加计算开销。max_depth：这个参数指定了每棵决策树的最大深度（默认值为None）。限制决策树的深度可以防止过拟合，但如果设置得太小，模型可能无法捕捉到复杂的关系。random_state：这个参数控制随机性的种子（默认值为None）。设置random_state可以使得每次运行模型时得到相同的结果，便于结果的复现性。&quot;&quot;&quot;# 四个featuresmodel.fit(X, y)# 模型训练完毕，预测测试数据中的结果predictions = model.predict(X_test)# 输出结果output = pd.DataFrame(&#123;&#x27;PassengerId&#x27;: test_data.PassengerId, &#x27;Survived&#x27;: predictions&#125;)output.to_csv(&#x27;submission_randomforest.csv&#x27;, index=False)print(&quot;Your submission was successfully saved!&quot;) Logic Regression（softmax）12345678910111213141516171819202122232425262728293031323334353637import numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)# 使用逻辑回归模型from sklearn.linear_model import LogisticRegression# 训练数据train_data = pd.read_csv(&quot;Input/titanic/train.csv&quot;)# print(train_data.head().isnull().sum()) # 检测是否有缺失数据# 测试数据test_data = pd.read_csv(&quot;Input/titanic/test.csv&quot;)# test_data.head()# 选出男女的存活人数women = train_data.loc[train_data.Sex == &#x27;female&#x27;][&quot;Survived&quot;]men = train_data.loc[train_data.Sex == &#x27;male&#x27;][&quot;Survived&quot;]rate_men = sum(men) / len(men) # 计算男人存活的概率rate_women = sum(women) / len(women) # 计算女人存活的概率y = train_data[&quot;Survived&quot;]features = [&quot;Pclass&quot;, &quot;Sex&quot;, &quot;SibSp&quot;, &quot;Parch&quot;]X = pd.get_dummies(train_data[features])X_test = pd.get_dummies(test_data[features])# 初始化逻辑回归模型model = LogisticRegression()model.fit(X, y)predictions = model.predict(X_test)output = pd.DataFrame(&#123;&#x27;PassengerId&#x27;: test_data.PassengerId, &#x27;Survived&#x27;: predictions&#125;)output.to_csv(&#x27;submission_logic.csv&#x27;, index=False)print(&quot;Your submission was successfully saved!&quot;)","categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"https://blog.xsaistudio.cn/tags/deep-learning/"}]},{"title":"QTablewidget使用","slug":"QTablewidget使用","date":"2023-05-14T08:13:10.000Z","updated":"2023-05-14T08:14:59.666Z","comments":true,"path":"2023/05/14/QTablewidget使用/","link":"","permalink":"https://blog.xsaistudio.cn/2023/05/14/QTablewidget%E4%BD%BF%E7%94%A8/","excerpt":"QTablewidget的各种使用方法","text":"QTablewidget的各种使用方法 隐藏行列123456789101112131415// 隐藏列ui-&gt;tableWidget-&gt;setColumnHidden(0, true); // 隐藏第一列ui-&gt;tableWidget-&gt;setColumnHidden(2, true); // 隐藏第三列// 隐藏行ui-&gt;tableWidget-&gt;setRowHidden(0, true); // 隐藏第一行ui-&gt;tableWidget-&gt;setRowHidden(2, true); // 隐藏第三行// 显示列ui-&gt;tableWidget-&gt;setColumnHidden(0, false); // 显示第一列ui-&gt;tableWidget-&gt;setColumnHidden(2, false); // 显示第三列// 显示行ui-&gt;tableWidget-&gt;setRowHidden(0, false); // 显示第一行ui-&gt;tableWidget-&gt;setRowHidden(2, false); // 显示第三行","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://blog.xsaistudio.cn/tags/QT/"},{"name":"C++","slug":"C","permalink":"https://blog.xsaistudio.cn/tags/C/"}]},{"title":"QCustomplot中X轴的操作","slug":"QCustomplot中X轴的操作","date":"2023-05-10T13:15:47.000Z","updated":"2023-05-12T10:04:50.885Z","comments":true,"path":"2023/05/10/QCustomplot中X轴的操作/","link":"","permalink":"https://blog.xsaistudio.cn/2023/05/10/QCustomplot%E4%B8%ADX%E8%BD%B4%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"关于我找错方向，测试了一晚的代码 这个是关于图像放缩的代码，具体看注释 123456789101112131415161718192021222324252627282930313233343536373839// key是x轴，value是y轴double currentRangeLower = ui_chart_-&gt;widget-&gt;xAxis-&gt;range().lower;double currentRangeUpper = ui_chart_-&gt;widget-&gt;xAxis-&gt;range().upper;double newRangeLower = data_pool_[i].data_list[i].time - 30;double newRangeUpper = data_pool_[i].data_list[i].time;// 移动 x 轴范围ui_chart_-&gt;widget-&gt;xAxis-&gt;moveRange(newRangeLower - currentRangeLower, newRangeUpper - currentRangeUpper);// 图像的首尾都确定custom_plot_-&gt;graph(0)-&gt;rescaleAxes(); // 改成了任意图像，没测试环境，不知是否有问题custom_plot_-&gt;graph(i)-&gt;rescaleAxes(true); // y轴不变，x轴始终首尾显示custom_plot_-&gt;graph(i)-&gt;rescaleKeyAxis(false); // y轴不动，不断地压缩图像，显示尾点custom_plot_-&gt;graph(i)-&gt;rescaleKeyAxis(true); // x轴不变，y轴始终显示最大最小，custom_plot_-&gt;graph(i)-&gt;rescaleValueAxis(rolling_flag); // 好像区别不大custom_plot_-&gt;graph(i)-&gt;rescaleValueAxis(true); // 和下面一样custom_plot_-&gt;graph(i)-&gt;rescaleValueAxis(false,false); // x轴不变，y轴始终显示最大最小，而且都贴着边轴custom_plot_-&gt;graph(i)-&gt;rescaleValueAxis(false,true); // 和下面一样custom_plot_-&gt;graph(i)-&gt;rescaleValueAxis(true,false); // x轴不变，y始终显示最大最小，不过缩放的是轴，图像没关系custom_plot_-&gt;graph(i)-&gt;rescaleValueAxis(true,true);","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://blog.xsaistudio.cn/tags/QT/"},{"name":"C++","slug":"C","permalink":"https://blog.xsaistudio.cn/tags/C/"}]},{"title":"Qt右键菜单","slug":"Qt右键菜单","date":"2023-05-10T13:04:21.000Z","updated":"2023-05-13T08:07:45.571Z","comments":true,"path":"2023/05/10/Qt右键菜单/","link":"","permalink":"https://blog.xsaistudio.cn/2023/05/10/Qt%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/","excerpt":"自定义qt右键菜单","text":"自定义qt右键菜单 说明​ QTextedit是 自带右键菜单的，如果要自己增加的话，会把原来的功能整的不能使用。 右键菜单123456789101112131415161718192021// 图表右键菜单 ui_chart_-&gt;widget-&gt;setContextMenuPolicy(Qt::CustomContextMenu); connect(ui_chart_-&gt;widget, &amp;QWidget::customContextMenuRequested, this, [&amp;](const QPoint pos) &#123; QMenu *menu = new QMenu(ui_chart_-&gt;widget); QAction *run = new QAction(&quot;开启滚动&quot;, ui_chart_-&gt;widget); QAction *stop = new QAction(&quot;停止滚动&quot;, ui_chart_-&gt;widget); connect(run, &amp;QAction::triggered, this, [&amp;] &#123; //怎么让它滚动 qDebug() &lt;&lt; &quot;run()&quot;; &#125;); connect(stop, &amp;QAction::triggered, this, [&amp;] &#123; //默认是不滚动的 qDebug() &lt;&lt; &quot;stop()&quot;; &#125;); menu-&gt;addAction(run); menu-&gt;addAction(stop); menu-&gt;move(cursor().pos()); menu-&gt;show(); 添加控件123456789101112131415161718192021222324QMenu *menu = new QMenu(ui_chart_-&gt;widget); QCheckBox *control = new QCheckBox(&quot;是否滚动&quot;,ui_chart_-&gt;widget); rolling_flag==true ? control-&gt;setCheckState(Qt::Checked) : control-&gt;setCheckState(Qt::Unchecked); // 设置选择框的默认状态 QWidgetAction *choice = new QWidgetAction(ui_chart_-&gt;widget); choice-&gt;setDefaultWidget(control); // 在Action对象中添加控件 QAction *restore = new QAction(&quot;自动&quot;, ui_chart_-&gt;widget); connect(control, &amp;QCheckBox::stateChanged, this, [&amp;,this](int state) &#123; state==Qt::Checked ? rolling_flag = true : rolling_flag = false; // 设置是否滚动 &#125;); connect(restore, &amp;QAction::triggered, this, [&amp;] &#123; //默认是不滚动的 qDebug() &lt;&lt; &quot;auto()&quot;; for (int i = 0; i &lt; data_pool_.size(); ++i) &#123; custom_plot_-&gt;graph(i)-&gt;rescaleAxes(); // 自动调整图像，首尾点都显示出来 &#125; &#125;); menu-&gt;addAction(choice); menu-&gt;addAction(restore); menu-&gt;move(cursor().pos()); // 这是什么？ menu-&gt;show();","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://blog.xsaistudio.cn/tags/QT/"},{"name":"C++","slug":"C","permalink":"https://blog.xsaistudio.cn/tags/C/"}]},{"title":"d2l环境配置","slug":"d2l环境配置","date":"2023-04-22T04:59:09.000Z","updated":"2023-04-23T09:38:05.165Z","comments":true,"path":"2023/04/22/d2l环境配置/","link":"","permalink":"https://blog.xsaistudio.cn/2023/04/22/d2l%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"在win11平台上部署d2l测试环境的步骤，以及遇到的问题。","text":"在win11平台上部署d2l测试环境的步骤，以及遇到的问题。 NVIDIA显卡，安装CUBA​ 到NVIDIA官网，跟着安装提示装就行了。CUBA Cuda安装也有很多报错。。。 Warnning：​ cuda的版本要对应pytorch（GPU版），所以一定要选好再装。cuda版本也要和cunn的版本对应。 nvcc –version查看已安装的cuda的版本。 卸载​ 与普通软件卸载方式相同，在程序那里找CUDA的程序卸载，再清理注册表的垃圾。 Miniconda 先到 官网 下载对应的版本，按照提示安装好就行。 以管理员身份打开 Anaconda Prompt , Warnning: 以管理员身份运行，全装C盘了。。。 1conda create --name d2l python=3.9 -y ​ 安装Pytorch （这里安装的是cpu版） 12pip install torch==1.12.0pip install torchvision==0.13.0 删除 123# 直接删除就行pip uninstall torchpip uninstall torchvision 安装d2l包 1pip install d2l==0.17.6 离线下载 官网 找到对应的CUDA的版本，torch，torchvision，torchaudio的whl文件，然后进行离线安装 &#96;&#96;&#96;shellpip install *.whl # 直接把这部分安装 12345678910* 相关命令* pip list --查看已经安装好的库 ```python import torch print(torch.__version__) # 查看torch版本 print(torch.version.cuda) # 查看cuda版本 print(torch.backends.cudnn.version()) # 查看cudnn版本 问题conda命令不能在普通的powershell中使用​ 一般情况下，conda命令都是在Anaconda powershell promt中使用。 设置环境变量：在环境变量中添加Anaconda中包含conda.exe的文件夹目录。 #在终端运行 conda init powershell 12345678* 运行完毕再重启，这时候提示系统禁止运行脚本。修改计算机的执行策略* ```shell get-executionpolicy set-executionpolicy remotesigned # 选y set-executionpolicy restricted # 如果要改回来的话 这样子以后，终端默认启动aconda","categories":[],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://blog.xsaistudio.cn/tags/Deep-Learning/"}]},{"title":"如何在Clion中优雅地debug","slug":"如何在Clion中优雅地debug","date":"2023-04-22T03:29:39.000Z","updated":"2023-04-22T08:41:34.793Z","comments":true,"path":"2023/04/22/如何在Clion中优雅地debug/","link":"","permalink":"https://blog.xsaistudio.cn/2023/04/22/%E5%A6%82%E4%BD%95%E5%9C%A8Clion%E4%B8%AD%E4%BC%98%E9%9B%85%E5%9C%B0debug/","excerpt":"各种debug的技巧，Clion的优点","text":"各种debug的技巧，Clion的优点 内存泄漏问题​ Clion的debug可以设置在程序出现异常的前一步中断住，这样可以看是哪一步的问题。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.xsaistudio.cn/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.xsaistudio.cn/tags/Qt/"}]},{"title":"Qcustomplot之修改颜色","slug":"Qcustomplor之修改颜色","date":"2023-04-04T15:41:03.000Z","updated":"2023-04-20T02:33:18.504Z","comments":true,"path":"2023/04/04/Qcustomplor之修改颜色/","link":"","permalink":"https://blog.xsaistudio.cn/2023/04/04/Qcustomplor%E4%B9%8B%E4%BF%AE%E6%94%B9%E9%A2%9C%E8%89%B2/","excerpt":"图像的颜色修改, 控件的颜色修改","text":"图像的颜色修改, 控件的颜色修改 Palette类型 改变控件颜色 先获取控件 1QPalette plet = line_[i].choose_color-&gt;palette(); 修改控件颜色 1plet.setColor (QPalette::Button, color) // color 为 QColor类型 QPen 图像颜色修改 直接修改掉QPen的变量即可, 直接对图像进行颜色赋值 12pen.setColor (data_pool_.at(i),color);ui_chart_-&gt;widget-&gt;graph(i)-&gt;setPen(pen); 1234567891011121314151617QPalette plet = line_info_[i].choose_color-&gt;palette();QColor currentColor = plet.color(QPalette::Button); // 当前颜色QColor color = QColorDialog::getColor(currentColor, this,(&quot;颜色选择&quot;));if (color.isValid())&#123; plet.setColor (QPalette::Button, color); line_info_[i].choose_color-&gt;setPalette (plet); data_pool_[i].line_color = color; // 这句话好像可以删掉 // 改变图像属性 QPen pen; pen.setWidth(data_pool_.at(i).line_width);//设置线宽,默认是2 pen.setColor(data_pool_.at(i).line_color);//设置线条红色 ui_chart_-&gt;widget-&gt;graph(i)-&gt;setPen(pen);&#125;","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://blog.xsaistudio.cn/tags/QT/"},{"name":"C++","slug":"C","permalink":"https://blog.xsaistudio.cn/tags/C/"}]},{"title":"Clion与QT的那些事","slug":"如何安装QT版本弃子","date":"2023-03-13T05:59:48.000Z","updated":"2023-04-04T15:37:53.878Z","comments":true,"path":"2023/03/13/如何安装QT版本弃子/","link":"","permalink":"https://blog.xsaistudio.cn/2023/03/13/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85QT%E7%89%88%E6%9C%AC%E5%BC%83%E5%AD%90/","excerpt":"因为QT6很多库已经放弃了，所以开发要用到旧版，找了很久才找到。","text":"因为QT6很多库已经放弃了，所以开发要用到旧版，找了很久才找到。 QT的在线安装程序，最低版本已经去到了v5.15，虽然区别不大，但还是统一开发环境比较好。 QT老版本下载: qtdownload QT论坛: Qt Forum QT在线安装器加载源的问题​ 问题：1. 添加的源用不了 2. 官方的源用不了 使用终端打开安装器, 在后面加上 –mirror https://mirrors.aliyun.com/qt 如 .\\qt_online.exe –mirror https://mirrors.aliyun.com/qt 用Clion开发QT 正常下载好QT, 创建好项目并且可以运行 QT安装可以用在线工具, 也可以下载离线安装包 安装的时候, 一定要选编译器(上下都要选)… Clion中配置好QT的工具链 在Tools chain中添加QT的debug, 把qt&#x2F;Tools&#x2F;5.12.12&#x2F;Mingw 添加上去 关于windows环境变量添加完环境变量，一定要重启！！！（除非你用在cmd用命令添加的） Clion编译QT程序的问题 找不到qt-config.cmake 在CMake.list程序里面，添加上set(CMAKE_PREFIX_PATH “E:\\\\QT\\\\5.12.11\\\\mingw73_64\\\\lib\\\\cmake\\\\Qt5”) 此处改为自己的路径 找不到对应的库，比如说这次(qserialport) 先去找官网或者别的地方找，看看每个版本之间的差异，可能版本的迭代把某些模块删掉了。 Clion编译通过了，但是运行报错-1073741515 (0xC0000135) 运行失败，这个报错是没有链接到动态链接库dll的原因，在系统环境变量中加上qt的编译路径，如： 最后一定要重启!!! 总结 装软件一定要考虑团队的版本问题, 还有安装时所带的资料库 windows环境变量设置完之后, 一定要重启电脑 网上搜教程的同时, 也要去官方论坛看看, bing国际版","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://blog.xsaistudio.cn/tags/QT/"},{"name":"Install","slug":"Install","permalink":"https://blog.xsaistudio.cn/tags/Install/"}]},{"title":"QT修改槽函数，lambda表达，正则表达","slug":"QT修改槽函数，lambda表达，正则表达","date":"2023-03-09T02:57:53.000Z","updated":"2023-03-09T05:28:14.058Z","comments":true,"path":"2023/03/09/QT修改槽函数，lambda表达，正则表达/","link":"","permalink":"https://blog.xsaistudio.cn/2023/03/09/QT%E4%BF%AE%E6%94%B9%E6%A7%BD%E5%87%BD%E6%95%B0%EF%BC%8Clambda%E8%A1%A8%E8%BE%BE%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/","excerpt":"QT自定义信号，修改槽函数，lambda表达式，正则表达","text":"QT自定义信号，修改槽函数，lambda表达式，正则表达 修改槽函数 在private slots 里面添加自定义函数声明，其它的按照官方操作就行 在widget.cpp 里面写connect函数 函数原型： static QMetaObject::Connection connect(const QObject *sender, const char *signal, const QObject *receiver, const char *member, Qt::ConnectionType &#x3D; Qt::AutoConnection); 12345QObject::connect(信号的发送者，发送的信号，槽函数所在的类，自定义接收的槽函数)eg： QObject::connect(ui-&gt;commit,&amp;QPushButton::clicked,this,&amp;Widget::botton); //QT5规范 QObject::connect(ui-&gt;commit,SIGNAL(clicked(),this,SLOT(botton())); //QT4规范 自定义信号Qt自定义信号和槽函数 lambda表达式通过lambada表达式，实现匿名函数的方法。在connect 使用匿名函数不能用QT4规范。 lambda捕获列表： [var]表示值传递方式捕捉变量var； [&#x3D;]表示值传递方式捕捉所有父作用域的变量（包括this）； [&amp;var]表示引用传递捕捉变量var； [&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）； 在QT中, 虽然是传地址, 但是修改了原来变量的值, 但是新的变量值不变, 实现了一部分传值, 一部分传地址 [this]表示值传递方式捕捉当前的this指针。上面提到了一个父作用域，也就是包含Lambda函数的语句块，说通俗点就是包含Lambda的“{}”代码块。上面的捕捉列表还可以进行组合，例如： [&#x3D;,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量; [&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。不过值得注意的是，捕捉列表不允许变量重复传递。下面一些例子就是典型的重复，会导致编译时期的错误。例如： [&#x3D;,a]这里已经以值传递方式捕捉了所有变量，但是重复捕捉a了，会报错的; [&amp;,&amp;this]这里&amp;已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。 1234QObject::connect(信号的发送者，发送的信号，槽函数所在的类，[捕获列表](信号里有的变量))connect(ui-&gt;commit,&amp;QPushButton::clicked,this,[=]&#123; qDebug() &lt;&lt; &quot;This is lambda&quot;;&#125;); 小问题 使用lambda的时候, 用cennect三个参数的重载, 会被clazy警告, 要用四个参数的重载 写了lambda表达式之后，slots那里已经不需要写任何东西 QT的正则表达基本操作1234567891011121314151617181920212223#include &lt;QRegularExpression&gt;QRegularExpression regexp_int(&quot;^[0-9]+$&quot;); // intQRegularExpression regexp_float(&quot;^[0-9]+\\\\.[0-9]+$&quot;); // float 匹配浮点数,要用两个\\\\转义.bool valid = regexp_int.isValid(); // 判断正则表达是否合法QString pattern = regexp.pattern(); // 返回正则表达式qDebug() &lt;&lt; pattern;QRegularExpressionMatch number = regexp_int.match(&quot;abdc 12&quot;); // 匹配出符合的结果 bool hasMatch = number.hasMatch(); // 是否匹配成功qDebug() &lt;&lt; hasMatch;if (number.hasMatch())&#123; QString numbers = number.captured(0); // 获取正则匹配结果 // 还有 captured(1) captured(2) qDebug() &lt;&lt; numbers;&#125;else&#123; qDebug() &lt;&lt; &quot;hasnt enough match&quot;;&#125; 后面需要用到再查手册","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://blog.xsaistudio.cn/tags/QT/"},{"name":"C++","slug":"C","permalink":"https://blog.xsaistudio.cn/tags/C/"}]},{"title":"git高阶用法","slug":"git快速入门","date":"2023-03-06T13:15:51.000Z","updated":"2023-04-01T16:50:27.342Z","comments":true,"path":"2023/03/06/git快速入门/","link":"","permalink":"https://blog.xsaistudio.cn/2023/03/06/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"git 的基本操作，参考 git技能树","text":"git 的基本操作，参考 git技能树 基操 以下文件均用变量 FILE 表示 比较变动 查看相对于上一次暂存修改了什么 1git diff FILE 查看日志 输出信息太多, 在后面加上 –pretty&#x3D;online 1git log --pretty=online 查看所有的commit记录 1git log 查看时间线 查看历史提交的时间线 1git lg 版本回退 在git 中, 当前版本表示HEAD, 上一个版本为HEAD^, 上上个版本为HEAD^^, 依此类推, 100个写成HEAD~100 1git reset --hard HEAD^ git重置 相当于撤销命令 123git reflog #查看用过的命令#找到想要撤回到的命令前面的idgit reflog --hard (e55063a) #这里填自己命令id git log 和 git reflog123456git log # 查看commit过的信息git reflog # 查看用过的命令git reset --hard commit_id # 回到该版本git reset --hard cmd_id # 回到用这条命令前的状态# 本地reset之后，要push上去，远程仓库才能一起回退 取消暂存文件 移除部分在暂存区的文件, 有些命令可以在 git status 中看到 1git reset HEAD FILE 恢复文件 将文件恢复为上一次提交的样子 1git checkout -- FILE 删除文件 两种情况: 误删, 想要恢复。彻底删除 误删( 前提是版本库里面存在 ) 1git checkout -- FILE # 跟上面同理 彻底删除 12# 先在本地删除, 然后才删除版本库里面的git rm FILE 删除远程仓库文件 12345678910#将远程仓库里面的项目文件拉下来，然后可通过dir命令行查看有哪些文件夹git pull origin master#删除文件(如“动画demo.md‘)或者文件夹git rm --cached “文件”/git rm -r --cached &quot;文件夹’#将删除操作提交到git仓库git commit -m “操作说明”#将本次修改更新到github远程仓库git push -u origin master# 这个删除对本地是没影响的,只是针对git本地库和远程库 分支管理 以下表示: 分支默认用dev 创建分支12git branch devgit branch -a # 查看本地分支以及远程分支 切换分支12345678# git checkout dev 已经过时了git switch dev# 创建和切换结合起来git switch -c dev# 将远程分支更新到本地（好像不能成功）git remote update origin --prune 指定分支下载1git clone -b branch_name git@git... 删除分支12git push origin --delete branch_name # 删除远程git branch -d branch_name # 删除本地 分支管理策略 通常合并分支的时候, 会采用Fast forward 模式, 这种模式下, 删除分支后相关的信息也会删除 如果禁用了这种模式, merge的时候会生成新的commit信息, 在历史上就能查到分支信息 1git merge --no-ff -m &quot;merge with no-ff&quot; dev # 这里加上了-m, 因为要产生新的commit信息 bug分支 工作到一半, 工作区还有东西, 同时还要改bug的情况 12345git stash # 把当前的工作区储存起来git stash list # 查看储存的工作区git stash apply (id) # 仅恢复工作区,当多个stash的时候,写idgit stash drop # 删除储存的工作区git stash pop # 恢复的同时,删除储存的工作区 同一个bug, 在两个不同的分支, 改完bug, 可以复刻特定的提交到其它分支 1git cherry-pick (id) # id填commit bug时候的id feature分支加速访问 steam++ uu加速器","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://blog.xsaistudio.cn/tags/git/"}]},{"title":"Ubuntu20.04安装ROS","slug":"Ubuntu20-04安装ROS","date":"2023-02-27T02:37:50.000Z","updated":"2023-02-27T14:14:28.473Z","comments":true,"path":"2023/02/27/Ubuntu20-04安装ROS/","link":"","permalink":"https://blog.xsaistudio.cn/2023/02/27/Ubuntu20-04%E5%AE%89%E8%A3%85ROS/","excerpt":"Ubuntu20.04安装ROS基本步骤，遇到的问题，小乌龟测试。ROS系统目前流行有两个版本：noetic和melodic。还有很多ROS发行版。","text":"Ubuntu20.04安装ROS基本步骤，遇到的问题，小乌龟测试。ROS系统目前流行有两个版本：noetic和melodic。还有很多ROS发行版。 安装ROS添加软件包路径1sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 设置ROS版本密钥（哪里拿的还不知道）12sudo apt install curl #安装curl工具curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 安装、初始化环境变量12345sudo apt update #更新一下源sudo apt install ros-noetic-desktop-full #安装ROS完全版source /opt/ros/noetic/setup.bash echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc #均为配置环境变量 安装各种依赖包1sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential #安装各种依赖包 管理各种工具的软件1sudo apt install python3-rosdep #安装管理工具 初始化rosdep（先别执行这里，先看下去）12sudo rosdep init rosdep update 替换rosdep相关链接 因为某些链接,在国内被屏蔽了,所以不能初始化成功. 下面需要手动配置链接. 手动克隆文件: 12cd /opt/ros/noetic/ #一定要切换到这个目录git clone https://github.com/ros/rosdistro.git #克隆ros官方文件 需要修改的文件有: 123456789/opt/ros/noetic/rosdistro/rosdep/sources.list.d/20-default.list #跟下面的不一样/usr/lib/python3/dist-packages/rosdep2/gbpdistro_support.py/usr/lib/python3/dist-packages/rosdep2/rep3.py/usr/lib/python3/dist-packages/rosdistro/__init__.py/etc/ros/rosdep/sources.list.d/20-default.list #别以为是一样的 修改详情请看:Ubuntu20.04.4安装ROS Noetic详细教程 安装遇到的问题 rosdep初始化失败问题：国内屏蔽了下载链接 运行小乌龟键盘控制不了：鼠标要选中控制节点的那个窗口，而不是选中小乌龟的窗口 参考资料ROS-wiki noetic&#x2F;Installation&#x2F;Ubuntu - ROS Wiki zhihu Ubuntu20.04.4安装ROS Noetic详细教程","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.xsaistudio.cn/tags/Ubuntu/"},{"name":"ROS","slug":"ROS","permalink":"https://blog.xsaistudio.cn/tags/ROS/"},{"name":"Gazebo","slug":"Gazebo","permalink":"https://blog.xsaistudio.cn/tags/Gazebo/"}]},{"title":"SD模块以及FATFS文件系统","slug":"SD模块以及FATFS文件系统","date":"2023-02-20T13:33:49.000Z","updated":"2023-03-14T06:21:01.617Z","comments":true,"path":"2023/02/20/SD模块以及FATFS文件系统/","link":"","permalink":"https://blog.xsaistudio.cn/2023/02/20/SD%E6%A8%A1%E5%9D%97%E4%BB%A5%E5%8F%8AFATFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"23科创杯模块, 使用SD卡读写, SPI通讯协议","text":"23科创杯模块, 使用SD卡读写, SPI通讯协议 某些资料 CMD0 使SD卡进入空闲模式 ​ 正确情况：返回1，但是返回了0 CMD8 查看SD卡版本，1 为2.0 CMD55 CMD41 CMD58 将初始化函数放进disk文件中，挂载出来是13， 外面初始化，里面初始化，挂在出来是13 外面初始化，里面不初始化，挂出来是3","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"STM32","slug":"STM32","permalink":"https://blog.xsaistudio.cn/tags/STM32/"},{"name":"模块","slug":"模块","permalink":"https://blog.xsaistudio.cn/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"电机驱动","slug":"电机驱动","date":"2023-01-31T09:56:10.000Z","updated":"2023-02-14T06:16:39.404Z","comments":true,"path":"2023/01/31/电机驱动/","link":"","permalink":"https://blog.xsaistudio.cn/2023/01/31/%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8/","excerpt":"电机驱动原理、TB6612接线、PID","text":"电机驱动原理、TB6612接线、PID 发现电机的正转比反转转速更快 正转满速：4900&#x2F;0.5s 反转满速：-5200&#x2F;0.5s 遇到问题 创建了野指针，导致程序无法正常运行 使用scanf 用了scanf，不需要再使用中断接收，中断回调这些函数了，记得子啊cube开启串口中断就行了，直接调用scanf就行了 还有这里的scanf和C里面的不一样，在格式输入里没有字符 即使是写成scanf(“kp&#x3D;%d”),scanf(“%d,%d”)，这种形式都不行 不过scanf(“%d%d%d”)，输入的时候可以写1，1，1 。中间可以加逗号","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"模块","slug":"模块","permalink":"https://blog.xsaistudio.cn/tags/%E6%A8%A1%E5%9D%97/"},{"name":"电机","slug":"电机","permalink":"https://blog.xsaistudio.cn/tags/%E7%94%B5%E6%9C%BA/"}]},{"title":"蓝牙小车之改bug","slug":"蓝牙小车之改bug","date":"2023-01-09T15:21:26.000Z","updated":"2023-03-16T14:36:06.497Z","comments":true,"path":"2023/01/09/蓝牙小车之改bug/","link":"","permalink":"https://blog.xsaistudio.cn/2023/01/09/%E8%93%9D%E7%89%99%E5%B0%8F%E8%BD%A6%E4%B9%8B%E6%94%B9bug/","excerpt":"经典写代码半小时，改bug两小时","text":"经典写代码半小时，改bug两小时 串口接收中断 在cube配置UART的时候,忘记在中断接收那里✔了… 串口接收数据过程 发送数据时,是整体打包发送. (在中断回调函数中)在接收的时候,是一位一位读取的,在检测到后面两个截止位的时候,就会停止接收,进入下一个任务. 如果在检测到截止位就立即清空数据包, 那么在外面的大循环中就无法判断到接收到的数据包, 应该在执行完判断任务后再清空. 串口接收到的数据包 通过普通的usb转串口模块,接收到的数据包有两个截止位(0X0D,0X0A) 但是用蓝牙通信发送的,只是软件上配置的数据,没有加截止位 printf的重定向在usart.c源文件中(针对于 cube),添加下面的代码 12345678910111213141516#include &lt;stdio.h&gt;extern UART_HandleTypeDef huart1;//只重定向到了UART1//重定向printf函数到串口int fputc(int ch,FILE* f)&#123; HAL_UART_Transmit(&amp;huart1,(uint8_t* )&amp;ch,1,1000); //注意这里的int类型的ch,要强制转换一下类型 return ch;&#125;//重定向scanf函数到串口int fgetc(FILE* F)&#123; uint8_t ch_r = 0; HAL_UART_Receive(&amp;huart1,&amp;ch_r,1,0xffff); return ch_r;&#125; 重定向原理: printf默认输出设备是显示器终端,如果要显示到串口或者lcd之类上,就要重定向. 注意 : 还要在keil上勾选use microlib sizeof的计算 sizeof计算的是定义到的数组长度,也就是定义了多少,计算出来就是多少 . 还有一个计算是实际的长度,忘记是什么函数了 如果里面传的是指针的话，这就是另一种情况了 STM32cube配置出现中文乱码（错误的）在Windows的环境变量中加入这个, 这种方法目前还没测试过. 变量名称：JAVA_TOOL_OPTIONS 变量值：-Dfile.encoding &#x3D; UTF-8 PID 的那些事Question： 如果在空转的时候，调好的pid，落地后，会不会影响结果？ 模块化编程问题函数调用之间的问题，传参问题，数据处理之后的操作","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"STM32","slug":"STM32","permalink":"https://blog.xsaistudio.cn/tags/STM32/"},{"name":"HAL","slug":"HAL","permalink":"https://blog.xsaistudio.cn/tags/HAL/"}]},{"title":"HAL之UART","slug":"HAL之UART","date":"2023-01-07T12:24:03.000Z","updated":"2023-02-01T00:58:22.343Z","comments":true,"path":"2023/01/07/HAL之UART/","link":"","permalink":"https://blog.xsaistudio.cn/2023/01/07/HAL%E4%B9%8BUART/","excerpt":"UART常用函数，HAL库的串口中断流程","text":"UART常用函数，HAL库的串口中断流程 HAL_UART_Transmit(); 串口发送数据，使用超时管理机制HAL_UART_Transmit_IT(); 串口中断模式发送HAL_UART_Transmit_DMA(); 串口DMA模式发送 HAL_UART_Receive_IT(); 串口中断模式接收HAL_UART_Receive(); 串口接收数据，使用超时管理机制HAL_UART_Transmit_DMA(); 串口DMA模式接收 串口中断流程12345HAL_UART_Receive_IT //中断接收函数USART2_IRQHandler(void) //中断服务函数HAL_UART_IRQHandler(*huart) //中断处理函数UART_Receive_IT(*huart) //接收函数HAL_UART_RxCpltCallback(huart) //中断回调函数(要自己修改) 12graph TBA(中断接收函数)--&gt;B(中断服务函数)--&gt;C(中断处理函数)--&gt;D(接收函数)--&gt;E(中断回调函数)--&gt;A(中断接收函数)","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"STM32","slug":"STM32","permalink":"https://blog.xsaistudio.cn/tags/STM32/"},{"name":"HAL","slug":"HAL","permalink":"https://blog.xsaistudio.cn/tags/HAL/"}]},{"title":"HAL之GPIO","slug":"HAL之GPIO","date":"2023-01-07T09:40:59.000Z","updated":"2023-01-07T12:24:45.797Z","comments":true,"path":"2023/01/07/HAL之GPIO/","link":"","permalink":"https://blog.xsaistudio.cn/2023/01/07/HAL%E4%B9%8BGPIO/","excerpt":"常用的GPIO函数以及工作模式","text":"常用的GPIO函数以及工作模式 常用函数输入函数 HAL_GPIO_ReadPin() &#x2F;&#x2F;读取引脚电平 输出函数 HAL_GPIO_WritePin() &#x2F;&#x2F;写入高低电平 HAL_GPIO_TogglePin() &#x2F;&#x2F;反转电平 中断函数 HAL_GPIO_EXTI_IRQHandler() &#x2F;&#x2F;外部中断服务函数 HAL_GPIO_EXTI_Callback() &#x2F;&#x2F;外部中断回调函数 工作模式输入模式GPIO_Input浮空输入 引脚电平是真实的外部连接器件电压，电平有不确定性 上拉输入 默认通过电阻上拉到VCC,不接外部器件时可以读出高电平 下拉输入 默认通过电阻下拉到GND,不接外部器件时可以读出低电平 输出模式推挽(push pull) 一种使用一对选择性地从相连负载灌电流或者拉电流的器件的电路。 开漏(open drain) 高电平时没有驱动能力，需要借助外部上拉电阻完成对外驱动。 浮空(no-pull-) 引脚电平是真实的外部连接器件电压，电平有不确定性 上拉 默认通过电阻上拉到VCC,不接外部器件时可以输出高电平 下拉 默认通过电阻下拉到GND,不接外部器件时可以输出低电平","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"STM32","slug":"STM32","permalink":"https://blog.xsaistudio.cn/tags/STM32/"},{"name":"HAL","slug":"HAL","permalink":"https://blog.xsaistudio.cn/tags/HAL/"}]},{"title":"蓝牙模块HC-05","slug":"蓝牙模块HC-05","date":"2023-01-07T03:32:23.000Z","updated":"2023-01-07T12:37:11.400Z","comments":true,"path":"2023/01/07/蓝牙模块HC-05/","link":"","permalink":"https://blog.xsaistudio.cn/2023/01/07/%E8%93%9D%E7%89%99%E6%A8%A1%E5%9D%97HC-05/","excerpt":"HC-05蓝牙模块基本原理及使用方法","text":"HC-05蓝牙模块基本原理及使用方法 波特率 AT测试的波特率默认为38400,1停止位,8数据位 蓝牙通信波特率默认为9600,0,0 AT测试 接线: GND-&gt;GND RXD-&gt;TXD TXD-&gt;RXD VCC-&gt;5V EN和STATE不接 注意: 模块上的VCC不能接3.3V, 资料说不可以，但是我接VCC和3V3都没问题。 按住模块上的按键再去供电, 进入慢闪(一秒一次)模式，即为AT测试 AT测试命令1234567891011121314151617181. 先输入AT，当返回OK时，代表进入AT测试AT+VERSION //当前版本AT+ORGL //恢复出厂设置AT+RESET //复位AT+NAME //蓝牙名字AT+PSWD //连接密码AT+ROLE //模式选择 1：从机 2：主机 3：回环AT+UART //波特率AT+ADDR //蓝牙地址码AT+STATE //当前工作状态AT+DISC //断开连接AT+RNAME //获取远程蓝牙设备名称AT+ADCN //获取蓝牙配对表中设备个数...... 蓝牙连接AT测试，查询完相应数据后，拔掉电源。这次不用按按键，直接插电。模块的灯快闪，进入等待连接状态。 手机打开蓝牙调试器 , 蓝牙调试器介绍 找到设备, 默认的连接密码为1234.","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"模块","slug":"模块","permalink":"https://blog.xsaistudio.cn/tags/%E6%A8%A1%E5%9D%97/"}]},{"title":"L298N驱动","slug":"L298N驱动","date":"2023-01-06T10:00:10.000Z","updated":"2023-03-02T03:54:54.996Z","comments":true,"path":"2023/01/06/L298N驱动/","link":"","permalink":"https://blog.xsaistudio.cn/2023/01/06/L298N%E9%A9%B1%E5%8A%A8/","excerpt":"L298N原理图及驱动方式","text":"L298N原理图及驱动方式 L298N 原理图 接线方式 工作电压: 9~12v 将电池盒或者锂电池的正极接到上图的vcc 如果安装了5v跳线帽, 5v接口是用来给单片机供电的, 这种情况下, 供电电源的GND要分两条, 模块和单片机共地 如果用5V来给单片机供电的话, 可能会出问题, 因为没有稳压, 可能会有掉压的情况. 电机分别接上图8, 9 引脚7 驱动方式 电机 旋转方式 IN1 IN2 IN3 IN4 M1 正转 高 低 &#x2F; &#x2F; (左) 反转 低 高 &#x2F; &#x2F; 停止 低 低 &#x2F; &#x2F; M2 正转 &#x2F; &#x2F; 高 低 (右) 反转 &#x2F; &#x2F; 低 高 停止 &#x2F; &#x2F; 低 低 如果要用PWM调速的话, 要拔掉ENA和ENB的跳线帽, 将PWM输出到这两个引脚来实现PWM调速. IN口控制正反转, EN口用来调速","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"模块","slug":"模块","permalink":"https://blog.xsaistudio.cn/tags/%E6%A8%A1%E5%9D%97/"}]}],"categories":[],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"https://blog.xsaistudio.cn/tags/deep-learning/"},{"name":"QT","slug":"QT","permalink":"https://blog.xsaistudio.cn/tags/QT/"},{"name":"C++","slug":"C","permalink":"https://blog.xsaistudio.cn/tags/C/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://blog.xsaistudio.cn/tags/Deep-Learning/"},{"name":"Qt","slug":"Qt","permalink":"https://blog.xsaistudio.cn/tags/Qt/"},{"name":"Install","slug":"Install","permalink":"https://blog.xsaistudio.cn/tags/Install/"},{"name":"git","slug":"git","permalink":"https://blog.xsaistudio.cn/tags/git/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.xsaistudio.cn/tags/Ubuntu/"},{"name":"ROS","slug":"ROS","permalink":"https://blog.xsaistudio.cn/tags/ROS/"},{"name":"Gazebo","slug":"Gazebo","permalink":"https://blog.xsaistudio.cn/tags/Gazebo/"},{"name":"单片机","slug":"单片机","permalink":"https://blog.xsaistudio.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"STM32","slug":"STM32","permalink":"https://blog.xsaistudio.cn/tags/STM32/"},{"name":"模块","slug":"模块","permalink":"https://blog.xsaistudio.cn/tags/%E6%A8%A1%E5%9D%97/"},{"name":"电机","slug":"电机","permalink":"https://blog.xsaistudio.cn/tags/%E7%94%B5%E6%9C%BA/"},{"name":"HAL","slug":"HAL","permalink":"https://blog.xsaistudio.cn/tags/HAL/"}]}